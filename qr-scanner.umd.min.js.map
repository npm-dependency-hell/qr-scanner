{"version":3,"file":"qr-scanner.umd.min.js","sources":["src/qr-scanner.ts"],"sourcesContent":["class QrScanner {\r\n    static readonly DEFAULT_CANVAS_SIZE = 400;\r\n    static readonly NO_QR_CODE_FOUND = 'No QR code found';\r\n    private static _disableBarcodeDetector = false;\r\n    private static _workerMessageId = 0;\r\n\r\n    /** @deprecated */\r\n    static set WORKER_PATH(workerPath: string) {\r\n        console.warn('Setting QrScanner.WORKER_PATH is not required and not supported anymore. '\r\n            + 'Have a look at the README for new setup instructions.');\r\n    }\r\n\r\n    static async hasCamera(): Promise<boolean> {\r\n        try {\r\n            return !!(await QrScanner.listCameras(false)).length;\r\n        } catch (e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    static async listCameras(requestLabels = false): Promise<Array<QrScanner.Camera>> {\r\n        if (!navigator.mediaDevices) return [];\r\n\r\n        const enumerateCameras = async (): Promise<Array<MediaDeviceInfo>> =>\r\n            (await navigator.mediaDevices.enumerateDevices()).filter((device) => device.kind === 'videoinput');\r\n\r\n        // Note that enumerateDevices can always be called and does not prompt the user for permission.\r\n        // However, enumerateDevices only includes device labels if served via https and an active media stream exists\r\n        // or permission to access the camera was given. Therefore, if we're not getting labels but labels are requested\r\n        // ask for camera permission by opening a stream.\r\n        let openedStream: MediaStream | undefined;\r\n        try {\r\n            if (requestLabels && (await enumerateCameras()).every((camera) => !camera.label)) {\r\n                openedStream = await navigator.mediaDevices.getUserMedia({ audio: false, video: true });\r\n            }\r\n        } catch (e) {\r\n            // Fail gracefully, especially if the device has no camera or on mobile when the camera is already in use\r\n            // and some browsers disallow a second stream.\r\n        }\r\n\r\n        try {\r\n            return (await enumerateCameras()).map((camera, i) => ({\r\n                id: camera.deviceId,\r\n                label: camera.label || (i === 0 ? 'Default Camera' : `Camera ${i + 1}`),\r\n            }));\r\n        } finally {\r\n            // close the stream we just opened for getting camera access for listing the device labels\r\n            if (openedStream) {\r\n                console.warn('Call listCameras after successfully starting a QR scanner to avoid creating '\r\n                    + 'a temporary video stream');\r\n                QrScanner._stopVideoStream(openedStream);\r\n            }\r\n        }\r\n    }\r\n\r\n    readonly $video: HTMLVideoElement;\r\n    readonly $canvas: HTMLCanvasElement;\r\n    readonly $fullCanvas: HTMLCanvasElement;\r\n    readonly $overlay?: HTMLDivElement;\r\n    private readonly $codeOutlineHighlight?: SVGSVGElement;\r\n    private readonly _onDecode?: (result: QrScanner.ScanResult) => void;\r\n    private readonly _legacyOnDecode?: (result: string) => void;\r\n    private readonly _legacyCanvasSize: number = QrScanner.DEFAULT_CANVAS_SIZE;\r\n    private _preferredCamera: QrScanner.FacingMode | QrScanner.DeviceId = 'environment';\r\n    private readonly _maxScansPerSecond: number = 25;\r\n    private _lastScanTimestamp: number = -1;\r\n    private _scanRegion: QrScanner.ScanRegion;\r\n    private _codeOutlineHighlightRemovalTimeout?: number;\r\n    private _qrEnginePromise: Promise<Worker | BarcodeDetector>\r\n    private _active: boolean = false;\r\n    private _paused: boolean = false;\r\n    private _flashOn: boolean = false;\r\n    private _destroyed: boolean = false;\r\n\r\n    constructor(\r\n        video: HTMLVideoElement,\r\n        onDecode: (result: QrScanner.ScanResult) => void,\r\n        options: {\r\n            onDecodeError?: (error: Error | string) => void,\r\n            calculateScanRegion?: (video: HTMLVideoElement) => QrScanner.ScanRegion,\r\n            preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\r\n            maxScansPerSecond?: number;\r\n            highlightScanRegion?: boolean,\r\n            highlightCodeOutline?: boolean,\r\n            overlay?: HTMLDivElement,\r\n            /** just a temporary flag until we switch entirely to the new api */\r\n            returnDetailedScanResult?: true,\r\n        },\r\n    );\r\n    /** @deprecated */\r\n    constructor(\r\n        video: HTMLVideoElement,\r\n        onDecode: (result: string) => void,\r\n        onDecodeError?: (error: Error | string) => void,\r\n        calculateScanRegion?: (video: HTMLVideoElement) => QrScanner.ScanRegion,\r\n        preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\r\n    );\r\n    /** @deprecated */\r\n    constructor(\r\n        video: HTMLVideoElement,\r\n        onDecode: (result: string) => void,\r\n        onDecodeError?: (error: Error | string) => void,\r\n        canvasSize?: number,\r\n        preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\r\n    );\r\n    /** @deprecated */\r\n    constructor(video: HTMLVideoElement, onDecode: (result: string) => void, canvasSize?: number);\r\n    constructor(\r\n        video: HTMLVideoElement,\r\n        onDecode: ((result: QrScanner.ScanResult) => void) | ((result: string) => void),\r\n        canvasSizeOrOnDecodeErrorOrOptions?: number | ((error: Error | string) => void) | {\r\n            onDecodeError?: (error: Error | string) => void,\r\n            calculateScanRegion?: (video: HTMLVideoElement) => QrScanner.ScanRegion,\r\n            preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\r\n            maxScansPerSecond?: number;\r\n            highlightScanRegion?: boolean,\r\n            highlightCodeOutline?: boolean,\r\n            overlay?: HTMLDivElement,\r\n            /** just a temporary flag until we switch entirely to the new api */\r\n            returnDetailedScanResult?: true,\r\n        },\r\n        canvasSizeOrCalculateScanRegion?: number | ((video: HTMLVideoElement) => QrScanner.ScanRegion),\r\n        preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\r\n    ) {\r\n        this.$video = video;\r\n        this.$canvas = document.createElement('canvas');\r\n        this.$fullCanvas = document.createElement('canvas');\r\n\r\n        if (canvasSizeOrOnDecodeErrorOrOptions && typeof canvasSizeOrOnDecodeErrorOrOptions === 'object') {\r\n            // we got an options object using the new api\r\n            this._onDecode = onDecode as QrScanner['_onDecode'];\r\n        } else {\r\n            if (canvasSizeOrOnDecodeErrorOrOptions || canvasSizeOrCalculateScanRegion || preferredCamera) {\r\n                console.warn('You\\'re using a deprecated version of the QrScanner constructor which will be removed in '\r\n                    + 'the future');\r\n            } else {\r\n                // Only video and onDecode were specified and we can't distinguish between new or old api usage. For\r\n                // backwards compatibility we have to assume the old api for now. The options object is marked as non-\r\n                // optional in the parameter list above to make clear that ScanResult instead of string is only passed\r\n                // if an options object was provided. However, in the future once legacy support is removed, the options\r\n                // object should become optional.\r\n                console.warn('Note that the type of the scan result passed to onDecode will change in the future. '\r\n                    + 'To already switch to the new api today, you can pass returnDetailedScanResult: true.');\r\n            }\r\n            this._legacyOnDecode = onDecode as QrScanner['_legacyOnDecode'];\r\n        }\r\n\r\n        const options = typeof canvasSizeOrOnDecodeErrorOrOptions === 'object'\r\n            ? canvasSizeOrOnDecodeErrorOrOptions\r\n            : {};\r\n        this._onDecodeError = options.onDecodeError || (typeof canvasSizeOrOnDecodeErrorOrOptions === 'function'\r\n            ? canvasSizeOrOnDecodeErrorOrOptions\r\n            : this._onDecodeError);\r\n        this._calculateScanRegion = options.calculateScanRegion || (typeof canvasSizeOrCalculateScanRegion==='function'\r\n            ? canvasSizeOrCalculateScanRegion\r\n            : this._calculateScanRegion);\r\n        this._preferredCamera = options.preferredCamera || preferredCamera || this._preferredCamera;\r\n        this._legacyCanvasSize = typeof canvasSizeOrOnDecodeErrorOrOptions === 'number'\r\n            ? canvasSizeOrOnDecodeErrorOrOptions\r\n            : typeof canvasSizeOrCalculateScanRegion === 'number'\r\n                ? canvasSizeOrCalculateScanRegion\r\n                : this._legacyCanvasSize;\r\n        this._maxScansPerSecond = options.maxScansPerSecond || this._maxScansPerSecond;\r\n\r\n        this._onPlay = this._onPlay.bind(this);\r\n        this._onLoadedMetaData = this._onLoadedMetaData.bind(this);\r\n        this._onVisibilityChange = this._onVisibilityChange.bind(this);\r\n        this._updateOverlay = this._updateOverlay.bind(this);\r\n\r\n        // @ts-ignore\r\n        video.disablePictureInPicture = true;\r\n        // Allow inline playback on iPhone instead of requiring full screen playback,\r\n        // see https://webkit.org/blog/6784/new-video-policies-for-ios/\r\n        // @ts-ignore\r\n        video.playsInline = true;\r\n        // Allow play() on iPhone without requiring a user gesture. Should not really be needed as camera stream\r\n        // includes no audio, but just to be safe.\r\n        video.muted = true;\r\n\r\n        // Avoid Safari stopping the video stream on a hidden video.\r\n        // See https://github.com/cozmo/jsQR/issues/185\r\n        let shouldHideVideo = false;\r\n        if (video.hidden) {\r\n            video.hidden = false;\r\n            shouldHideVideo = true;\r\n        }\r\n        if (!document.body.contains(video)) {\r\n            document.body.appendChild(video);\r\n            shouldHideVideo = true;\r\n        }\r\n        const videoContainer = video.parentElement!;\r\n\r\n        if (options.highlightScanRegion || options.highlightCodeOutline) {\r\n            const gotExternalOverlay = !!options.overlay;\r\n            this.$overlay = options.overlay || document.createElement('div');\r\n            const overlayStyle = this.$overlay.style;\r\n            overlayStyle.position = 'absolute';\r\n            overlayStyle.display = 'none';\r\n            overlayStyle.pointerEvents = 'none';\r\n            this.$overlay.classList.add('scan-region-highlight');\r\n            if (!gotExternalOverlay && options.highlightScanRegion) {\r\n                // default style; can be overwritten via css, e.g. by changing the svg's stroke color, hiding the\r\n                // .scan-region-highlight-svg, setting a border, outline, background, etc.\r\n                this.$overlay.innerHTML = '<svg class=\"scan-region-highlight-svg\" viewBox=\"0 0 238 238\" '\r\n                    + 'preserveAspectRatio=\"none\" style=\"position:absolute;width:100%;height:100%;left:0;top:0;'\r\n                    + 'fill:none;stroke:#e9b213;stroke-width:4;stroke-linecap:round;stroke-linejoin:round\">'\r\n                    + '<path d=\"M31 2H10a8 8 0 0 0-8 8v21M207 2h21a8 8 0 0 1 8 8v21m0 176v21a8 8 0 0 1-8 8h-21m-176 '\r\n                    + '0H10a8 8 0 0 1-8-8v-21\"/></svg>';\r\n                try {\r\n                    this.$overlay.firstElementChild!.animate({ transform: ['scale(.98)', 'scale(1.01)'] }, {\r\n                        duration: 400,\r\n                        iterations: Infinity,\r\n                        direction: 'alternate',\r\n                        easing: 'ease-in-out',\r\n                    });\r\n                } catch (e) {}\r\n                videoContainer.insertBefore(this.$overlay, this.$video.nextSibling);\r\n            }\r\n            if (options.highlightCodeOutline) {\r\n                // default style; can be overwritten via css\r\n                this.$overlay.insertAdjacentHTML(\r\n                    'beforeend',\r\n                    '<svg class=\"code-outline-highlight\" preserveAspectRatio=\"none\" style=\"display:none;width:100%;'\r\n                        + 'height:100%;fill:none;stroke:#e9b213;stroke-width:5;stroke-dasharray:25;'\r\n                        + 'stroke-linecap:round;stroke-linejoin:round\"><polygon/></svg>',\r\n                );\r\n                this.$codeOutlineHighlight = this.$overlay.lastElementChild as SVGSVGElement;\r\n            }\r\n        }\r\n        this._scanRegion = this._calculateScanRegion(video);\r\n\r\n        requestAnimationFrame(() => {\r\n            // Checking in requestAnimationFrame which should avoid a potential additional re-flow for getComputedStyle.\r\n            const videoStyle = window.getComputedStyle(video);\r\n            if (videoStyle.display === 'none') {\r\n                video.style.setProperty('display', 'block', 'important');\r\n                shouldHideVideo = true;\r\n            }\r\n            if (videoStyle.visibility !== 'visible') {\r\n                video.style.setProperty('visibility', 'visible', 'important');\r\n                shouldHideVideo = true;\r\n            }\r\n            if (shouldHideVideo) {\r\n                // Hide the video in a way that doesn't cause Safari to stop the playback.\r\n                console.warn('QrScanner has overwritten the video hiding style to avoid Safari stopping the playback.');\r\n                video.style.opacity = '0';\r\n                video.style.width = '0';\r\n                video.style.height = '0';\r\n                if (this.$overlay && this.$overlay.parentElement) {\r\n                    this.$overlay.parentElement.removeChild(this.$overlay);\r\n                }\r\n                // @ts-ignore\r\n                delete this.$overlay!;\r\n                // @ts-ignore\r\n                delete this.$codeOutlineHighlight!;\r\n            }\r\n\r\n            if (this.$overlay) {\r\n                this._updateOverlay();\r\n            }\r\n        });\r\n\r\n        video.addEventListener('play', this._onPlay);\r\n        video.addEventListener('loadedmetadata', this._onLoadedMetaData);\r\n        document.addEventListener('visibilitychange', this._onVisibilityChange);\r\n        window.addEventListener('resize', this._updateOverlay);\r\n\r\n        this._qrEnginePromise = QrScanner.createQrEngine();\r\n    }\r\n\r\n    async hasFlash(): Promise<boolean> {\r\n        let stream: MediaStream | undefined;\r\n        try {\r\n            if (this.$video.srcObject) {\r\n                if (!(this.$video.srcObject instanceof MediaStream)) return false; // srcObject is not a camera stream\r\n                stream = this.$video.srcObject;\r\n            } else {\r\n                stream = (await this._getCameraStream()).stream;\r\n            }\r\n            return 'torch' in stream.getVideoTracks()[0].getSettings();\r\n        } catch (e) {\r\n            return false;\r\n        } finally {\r\n            // close the stream we just opened for detecting whether it supports flash\r\n            if (stream && stream !== this.$video.srcObject) {\r\n                console.warn('Call hasFlash after successfully starting the scanner to avoid creating '\r\n                    + 'a temporary video stream');\r\n                QrScanner._stopVideoStream(stream);\r\n            }\r\n        }\r\n    }\r\n\r\n    isFlashOn(): boolean {\r\n        return this._flashOn;\r\n    }\r\n\r\n    async toggleFlash(): Promise<void> {\r\n        if (this._flashOn) {\r\n            await this.turnFlashOff();\r\n        } else {\r\n            await this.turnFlashOn();\r\n        }\r\n    }\r\n\r\n    async turnFlashOn(): Promise<void> {\r\n        if (this._flashOn || this._destroyed) return;\r\n        this._flashOn = true;\r\n        if (!this._active || this._paused) return; // flash will be turned on later on .start()\r\n        try {\r\n            if (!await this.hasFlash()) throw 'No flash available';\r\n            // Note that the video track is guaranteed to exist and to be a MediaStream due to the check in hasFlash\r\n            await (this.$video.srcObject as MediaStream).getVideoTracks()[0].applyConstraints({\r\n                // @ts-ignore: constraint 'torch' is unknown to ts\r\n                advanced: [{ torch: true }],\r\n            });\r\n        } catch (e) {\r\n            this._flashOn = false;\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    async turnFlashOff(): Promise<void> {\r\n        if (!this._flashOn) return;\r\n        // applyConstraints with torch: false does not work to turn the flashlight off, as a stream's torch stays\r\n        // continuously on, see https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints#torch. Therefore,\r\n        // we have to stop the stream to turn the flashlight off.\r\n        this._flashOn = false;\r\n        await this._restartVideoStream();\r\n    }\r\n\r\n    destroy(): void {\r\n        this.$video.removeEventListener('loadedmetadata', this._onLoadedMetaData);\r\n        this.$video.removeEventListener('play', this._onPlay);\r\n        document.removeEventListener('visibilitychange', this._onVisibilityChange);\r\n        window.removeEventListener('resize', this._updateOverlay);\r\n\r\n        this._destroyed = true;\r\n        this._flashOn = false;\r\n        this.stop(); // sets this._paused = true and this._active = false\r\n        QrScanner._postWorkerMessage(this._qrEnginePromise, 'close');\r\n    }\r\n\r\n    async start(): Promise<void> {\r\n        if (this._destroyed) throw new Error('The QR scanner can not be started as it had been destroyed.');\r\n        if (this._active && !this._paused) return;\r\n\r\n        if (window.location.protocol !== 'https:') {\r\n            // warn but try starting the camera anyways\r\n            console.warn('The camera stream is only accessible if the page is transferred via https.');\r\n        }\r\n\r\n        this._active = true;\r\n        if (document.hidden) return; // camera will be started as soon as tab is in foreground\r\n        this._paused = false;\r\n        if (this.$video.srcObject) {\r\n            // camera stream already/still set\r\n            await this.$video.play();\r\n            return;\r\n        }\r\n\r\n        try {\r\n            const { stream, facingMode } = await this._getCameraStream();\r\n            if (!this._active || this._paused) {\r\n                // was stopped in the meantime\r\n                QrScanner._stopVideoStream(stream);\r\n                return;\r\n            }\r\n            this._setVideoMirror(facingMode);\r\n            this.$video.srcObject = stream;\r\n            await this.$video.play();\r\n\r\n            // Restart the flash if it was previously on\r\n            if (this._flashOn) {\r\n                this._flashOn = false; // force turnFlashOn to restart the flash\r\n                this.turnFlashOn().catch(() => {});\r\n            }\r\n        } catch (e) {\r\n            if (this._paused) return;\r\n            this._active = false;\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    stop(): void {\r\n        this.pause();\r\n        this._active = false;\r\n    }\r\n\r\n    async pause(stopStreamImmediately = false): Promise<boolean> {\r\n        this._paused = true;\r\n        if (!this._active) return true;\r\n        this.$video.pause();\r\n\r\n        if (this.$overlay) {\r\n            this.$overlay.style.display = 'none';\r\n        }\r\n\r\n        const stopStream = () => {\r\n            if (this.$video.srcObject instanceof MediaStream) {\r\n                // revoke srcObject only if it's a stream which was likely set by us\r\n                QrScanner._stopVideoStream(this.$video.srcObject);\r\n                this.$video.srcObject = null;\r\n            }\r\n        };\r\n\r\n        if (stopStreamImmediately) {\r\n            stopStream();\r\n            return true;\r\n        }\r\n\r\n        await new Promise((resolve) => setTimeout(resolve, 300));\r\n        if (!this._paused) return false;\r\n        stopStream();\r\n        return true;\r\n    }\r\n\r\n    async setCamera(facingModeOrDeviceId: QrScanner.FacingMode | QrScanner.DeviceId): Promise<void> {\r\n        if (facingModeOrDeviceId === this._preferredCamera) return;\r\n        this._preferredCamera = facingModeOrDeviceId;\r\n        // Restart the scanner with the new camera which will also update the video mirror and the scan region.\r\n        await this._restartVideoStream();\r\n    }\r\n\r\n    static async scanImage(\r\n        imageOrFileOrBlobOrUrl: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\r\n            | SVGImageElement | File | Blob | URL | String,\r\n        options: {\r\n            scanRegion?: QrScanner.ScanRegion | null,\r\n            qrEngine?: Worker | BarcodeDetector | Promise<Worker | BarcodeDetector> | null,\r\n            canvas?: HTMLCanvasElement | null,\r\n            fullCanvas?: HTMLCanvasElement | null,\r\n            disallowCanvasResizing?: boolean,\r\n            alsoTryWithoutScanRegion?: boolean,\r\n            /** just a temporary flag until we switch entirely to the new api */\r\n            returnDetailedScanResult?: true,\r\n        },\r\n    ): Promise<QrScanner.ScanResult>;\r\n    /** @deprecated */\r\n    static async scanImage(\r\n        imageOrFileOrBlobOrUrl: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\r\n            | SVGImageElement | File | Blob | URL | String,\r\n        scanRegion?: QrScanner.ScanRegion | null,\r\n        qrEngine?: Worker | BarcodeDetector | Promise<Worker | BarcodeDetector> | null,\r\n        canvas?: HTMLCanvasElement | null,\r\n        fullCanvas?: HTMLCanvasElement | null,\r\n        disallowCanvasResizing?: boolean,\r\n        alsoTryWithoutScanRegion?: boolean,\r\n    ): Promise<string>;\r\n    static async scanImage(\r\n        imageOrFileOrBlobOrUrl: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\r\n            | SVGImageElement | File | Blob | URL | String,\r\n        scanRegionOrOptions?: QrScanner.ScanRegion | {\r\n            scanRegion?: QrScanner.ScanRegion | null,\r\n            qrEngine?: Worker | BarcodeDetector | Promise<Worker | BarcodeDetector> | null,\r\n            canvas?: HTMLCanvasElement | null,\r\n            disallowCanvasResizing?: boolean,\r\n            alsoTryWithoutScanRegion?: boolean,\r\n            /** just a temporary flag until we switch entirely to the new api */\r\n            returnDetailedScanResult?: true,\r\n        } | null,\r\n        qrEngine?: Worker | BarcodeDetector | Promise<Worker | BarcodeDetector> | null,\r\n        canvas?: HTMLCanvasElement | null,\r\n        fullCanvas?: HTMLCanvasElement | null,\r\n        disallowCanvasResizing: boolean = false,\r\n        alsoTryWithoutScanRegion: boolean = false,\r\n    ): Promise<string | QrScanner.ScanResult> {\r\n        let scanRegion: QrScanner.ScanRegion | null | undefined;\r\n        let returnDetailedScanResult = false;\r\n        if (scanRegionOrOptions && (\r\n            'scanRegion' in scanRegionOrOptions\r\n            || 'qrEngine' in scanRegionOrOptions\r\n            || 'canvas' in scanRegionOrOptions\r\n            || 'disallowCanvasResizing' in scanRegionOrOptions\r\n            || 'alsoTryWithoutScanRegion' in scanRegionOrOptions\r\n            || 'returnDetailedScanResult' in scanRegionOrOptions\r\n        )) {\r\n            // we got an options object using the new api\r\n            scanRegion = scanRegionOrOptions.scanRegion;\r\n            qrEngine = scanRegionOrOptions.qrEngine;\r\n            canvas = scanRegionOrOptions.canvas;\r\n            disallowCanvasResizing = scanRegionOrOptions.disallowCanvasResizing || false;\r\n            alsoTryWithoutScanRegion = scanRegionOrOptions.alsoTryWithoutScanRegion || false;\r\n            returnDetailedScanResult = true;\r\n        } else if (scanRegionOrOptions || qrEngine || canvas || disallowCanvasResizing || alsoTryWithoutScanRegion) {\r\n            console.warn('You\\'re using a deprecated api for scanImage which will be removed in the future.');\r\n        } else {\r\n            // Only imageOrFileOrBlobOrUrl was specified and we can't distinguish between new or old api usage. For\r\n            // backwards compatibility we have to assume the old api for now. The options object is marked as non-\r\n            // optional in the parameter list above to make clear that ScanResult instead of string is only returned if\r\n            // an options object was provided. However, in the future once legacy support is removed, the options object\r\n            // should become optional.\r\n            console.warn('Note that the return type of scanImage will change in the future. To already switch to the '\r\n                + 'new api today, you can pass returnDetailedScanResult: true.');\r\n        }\r\n\r\n        const gotExternalEngine = !!qrEngine;\r\n\r\n        try {\r\n            let image: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\r\n                | SVGImageElement;\r\n            let canvasContext: CanvasRenderingContext2D;\r\n            let fullCanvasContext: CanvasRenderingContext2D;\r\n            [qrEngine, image] = await Promise.all([\r\n                qrEngine || QrScanner.createQrEngine(),\r\n                QrScanner._loadImage(imageOrFileOrBlobOrUrl),\r\n            ]);\r\n            [canvas, canvasContext, fullCanvas, fullCanvasContext] = QrScanner._drawToCanvas(image, scanRegion, canvas, fullCanvas, disallowCanvasResizing);\r\n            let detailedScanResult: QrScanner.ScanResult;\r\n\r\n            if (qrEngine instanceof Worker) {\r\n                const qrEngineWorker = qrEngine; // for ts to know that it's still a worker later in the event listeners\r\n                if (!gotExternalEngine) {\r\n                    // Enable scanning of inverted color qr codes.\r\n                    QrScanner._postWorkerMessageSync(qrEngineWorker, 'inversionMode', 'both');\r\n                }\r\n                detailedScanResult = await new Promise((resolve, reject) => {\r\n                    let timeout: number;\r\n                    let onMessage: (event: MessageEvent) => void;\r\n                    let onError: (error: ErrorEvent | string) => void;\r\n                    let expectedResponseId = -1;\r\n                    onMessage = (event: MessageEvent) => {\r\n                        if (event.data.id !== expectedResponseId) {\r\n                            return;\r\n                        }\r\n                        qrEngineWorker.removeEventListener('message', onMessage);\r\n                        qrEngineWorker.removeEventListener('error', onError);\r\n                        clearTimeout(timeout);\r\n                        if (event.data.data !== null) {\r\n                            resolve({\r\n                                data: event.data.data,\r\n                                cornerPoints: QrScanner._convertPoints(event.data.cornerPoints, scanRegion),\r\n                                image: fullCanvas!,\r\n                            });\r\n                        } else {\r\n                            reject(QrScanner.NO_QR_CODE_FOUND);\r\n                        }\r\n                    };\r\n                    onError = (error: ErrorEvent | string) => {\r\n                        qrEngineWorker.removeEventListener('message', onMessage);\r\n                        qrEngineWorker.removeEventListener('error', onError);\r\n                        clearTimeout(timeout);\r\n                        const errorMessage = !error ? 'Unknown Error' : ((error as ErrorEvent).message || error);\r\n                        reject('Scanner error: ' + errorMessage);\r\n                    };\r\n                    qrEngineWorker.addEventListener('message', onMessage);\r\n                    qrEngineWorker.addEventListener('error', onError);\r\n                    timeout = setTimeout(() => onError('timeout'), 10000);\r\n                    const imageData = canvasContext.getImageData(0, 0, canvas!.width, canvas!.height);\r\n                    expectedResponseId = QrScanner._postWorkerMessageSync(\r\n                        qrEngineWorker,\r\n                        'decode',\r\n                        imageData,\r\n                        [imageData.data.buffer],\r\n                    );\r\n                });\r\n            } else {\r\n                detailedScanResult = await Promise.race([\r\n                    new Promise<QrScanner.ScanResult>((resolve, reject) => window.setTimeout(\r\n                        () => reject('Scanner error: timeout'),\r\n                        10000,\r\n                    )),\r\n                    (async (): Promise<QrScanner.ScanResult> => {\r\n                        try {\r\n                            const imageData = canvasContext.getImageData(0, 0, canvas!.width, canvas!.height);\r\n                            const [scanResult] = await qrEngine.detect(imageData!);\r\n                            if (!scanResult) throw QrScanner.NO_QR_CODE_FOUND;\r\n                            return {\r\n                                data: scanResult.rawValue,\r\n                                cornerPoints: QrScanner._convertPoints(scanResult.cornerPoints, scanRegion),\r\n                                image: fullCanvas!,\r\n                            };\r\n                        } catch (e) {\r\n                            const errorMessage = (e as Error).message || e as string;\r\n                            if (/not implemented|service unavailable/.test(errorMessage)) {\r\n                                // Not implemented can apparently for some reason happen even though getSupportedFormats\r\n                                // in createQrScanner reported that it's supported, see issue #98.\r\n                                // Service unavailable can happen after some time when the BarcodeDetector crashed and\r\n                                // can theoretically be recovered from by creating a new BarcodeDetector. However, in\r\n                                // newer browsers this issue does not seem to be present anymore and therefore we do not\r\n                                // apply this optimization anymore but just set _disableBarcodeDetector in both cases.\r\n                                // Also note that if we got an external qrEngine that crashed, we should possibly notify\r\n                                // the caller about it, but we also don't do this here, as it's such an unlikely case.\r\n                                QrScanner._disableBarcodeDetector = true;\r\n                                // retry without passing the broken BarcodeScanner instance\r\n                                return QrScanner.scanImage(imageOrFileOrBlobOrUrl, {\r\n                                    scanRegion,\r\n                                    canvas,\r\n                                    disallowCanvasResizing,\r\n                                    alsoTryWithoutScanRegion,\r\n                                });\r\n                            }\r\n                            throw `Scanner error: ${errorMessage}`;\r\n                        }\r\n                    })(),\r\n                ]);\r\n            }\r\n            return returnDetailedScanResult ? detailedScanResult : detailedScanResult.data;\r\n        } catch (e) {\r\n            if (!scanRegion || !alsoTryWithoutScanRegion) throw e;\r\n            const detailedScanResult = await QrScanner.scanImage(\r\n                imageOrFileOrBlobOrUrl,\r\n                { qrEngine, canvas, disallowCanvasResizing },\r\n            );\r\n            return returnDetailedScanResult ? detailedScanResult : detailedScanResult.data;\r\n        } finally {\r\n            if (!gotExternalEngine) {\r\n                QrScanner._postWorkerMessage(qrEngine!, 'close');\r\n            }\r\n        }\r\n    }\r\n\r\n    setGrayscaleWeights(red: number, green: number, blue: number, useIntegerApproximation: boolean = true): void {\r\n        // Note that for the native BarcodeDecoder or if the worker was destroyed, this is a no-op. However, the native\r\n        // implementations work also well with colored qr codes.\r\n        QrScanner._postWorkerMessage(\r\n            this._qrEnginePromise,\r\n            'grayscaleWeights',\r\n            { red, green, blue, useIntegerApproximation }\r\n        );\r\n    }\r\n\r\n    setInversionMode(inversionMode: QrScanner.InversionMode): void {\r\n        // Note that for the native BarcodeDecoder or if the worker was destroyed, this is a no-op. However, the native\r\n        // implementations scan normal and inverted qr codes by default\r\n        QrScanner._postWorkerMessage(this._qrEnginePromise, 'inversionMode', inversionMode);\r\n    }\r\n\r\n    static async createQrEngine(): Promise<Worker | BarcodeDetector>;\r\n    /** @deprecated */\r\n    static async createQrEngine(workerPath: string): Promise<Worker | BarcodeDetector>;\r\n    static async createQrEngine(workerPath?: string): Promise<Worker | BarcodeDetector> {\r\n        if (workerPath) {\r\n            console.warn('Specifying a worker path is not required and not supported anymore.');\r\n        }\r\n\r\n        // @ts-ignore no types defined for import\r\n        const createWorker = () => (import('./qr-scanner-worker.min.js') as Promise<{ createWorker: () => Worker }>)\r\n            .then((module) => module.createWorker());\r\n\r\n        const useBarcodeDetector = !QrScanner._disableBarcodeDetector\r\n            && 'BarcodeDetector' in window\r\n            && BarcodeDetector.getSupportedFormats\r\n            && (await BarcodeDetector.getSupportedFormats()).includes('qr_code');\r\n\r\n        if (!useBarcodeDetector) return createWorker();\r\n\r\n        // On Macs with an M1/M2 processor and macOS Ventura (macOS version 13), the BarcodeDetector is broken in\r\n        // Chromium based browsers, regardless of the version. For that constellation, the BarcodeDetector does not\r\n        // error but does not detect QR codes. Macs without an M1/M2 or before Ventura are fine.\r\n        // See issue #209 and https://bugs.chromium.org/p/chromium/issues/detail?id=1382442\r\n        // UPDATE: ISSUE RESOLVED in Chrome > 113 / CREDIT: \r\n        // Enable BarcodeDetector in M* chips in Chromium versions after 113 by alsherko (https://github.com/alsherko)\r\n        // https://github.com/nimiq/qr-scanner/pull/243/commits/8c01cd4d9d9ef1640246d1f96969e69111046e52\r\n        const userAgentData = navigator.userAgentData;\r\n        const isChromiumOnMacWithArmVentura = userAgentData // all Chromium browsers support userAgentData\r\n            && userAgentData.brands.some(({ brand, version }) => /Chromium/i.test(brand) && parseInt(version) < 113)\r\n            && /mac ?OS/i.test(userAgentData.platform)\r\n            // Does it have an ARM chip (e.g. M1/M2) and Ventura? Check this last as getHighEntropyValues can\r\n            // theoretically trigger a browser prompt, although no browser currently does seem to show one.\r\n            // If browser or user refused to return the requested values, assume broken ARM Ventura, to be safe.\r\n            && await userAgentData.getHighEntropyValues(['architecture', 'platformVersion'])\r\n                .then(({ architecture, platformVersion }) =>\r\n                    /arm/i.test(architecture || 'arm') && parseInt(platformVersion || '13') >= /* Ventura */ 13)\r\n                .catch(() => true);\r\n        if (isChromiumOnMacWithArmVentura) return createWorker();\r\n\r\n        return new BarcodeDetector({ formats: ['qr_code'] });\r\n    }\r\n\r\n    private _onPlay(): void {\r\n        this._scanRegion = this._calculateScanRegion(this.$video);\r\n        this._updateOverlay();\r\n        if (this.$overlay) {\r\n            this.$overlay.style.display = '';\r\n        }\r\n        this._scanFrame();\r\n    }\r\n\r\n    private _onLoadedMetaData(): void {\r\n        this._scanRegion = this._calculateScanRegion(this.$video);\r\n        this._updateOverlay();\r\n    }\r\n\r\n    private _onVisibilityChange(): void {\r\n        if (document.hidden) {\r\n            this.pause();\r\n        } else if (this._active) {\r\n            this.start();\r\n        }\r\n    }\r\n\r\n    private _calculateScanRegion(video: HTMLVideoElement): QrScanner.ScanRegion {\r\n        // Default scan region calculation. Note that this can be overwritten in the constructor.\r\n        const smallestDimension = Math.min(video.videoWidth, video.videoHeight);\r\n        const scanRegionSize = Math.round(2 / 3 * smallestDimension);\r\n        return {\r\n            x: Math.round((video.videoWidth - scanRegionSize) / 2),\r\n            y: Math.round((video.videoHeight - scanRegionSize) / 2),\r\n            width: scanRegionSize,\r\n            height: scanRegionSize,\r\n            downScaledWidth: this._legacyCanvasSize,\r\n            downScaledHeight: this._legacyCanvasSize,\r\n        };\r\n    }\r\n\r\n    private _updateOverlay(): void {\r\n        requestAnimationFrame(() => {\r\n            // Running in requestAnimationFrame which should avoid a potential additional re-flow for getComputedStyle\r\n            // and offsetWidth, offsetHeight, offsetLeft, offsetTop.\r\n            if (!this.$overlay) return;\r\n            const video = this.$video;\r\n            const videoWidth = video.videoWidth;\r\n            const videoHeight = video.videoHeight;\r\n            const elementWidth = video.offsetWidth;\r\n            const elementHeight = video.offsetHeight;\r\n            const elementX = video.offsetLeft;\r\n            const elementY = video.offsetTop;\r\n\r\n            const videoStyle = window.getComputedStyle(video);\r\n            const videoObjectFit = videoStyle.objectFit;\r\n            const videoAspectRatio = videoWidth / videoHeight;\r\n            const elementAspectRatio = elementWidth / elementHeight;\r\n            let videoScaledWidth: number;\r\n            let videoScaledHeight: number;\r\n            switch (videoObjectFit) {\r\n                case 'none':\r\n                    videoScaledWidth = videoWidth;\r\n                    videoScaledHeight = videoHeight;\r\n                    break;\r\n                case 'fill':\r\n                    videoScaledWidth = elementWidth;\r\n                    videoScaledHeight = elementHeight;\r\n                    break;\r\n                default: // 'cover', 'contains', 'scale-down'\r\n                    if (videoObjectFit === 'cover'\r\n                        ? videoAspectRatio > elementAspectRatio\r\n                        : videoAspectRatio < elementAspectRatio) {\r\n                        // The scaled height is the element height\r\n                        // - for 'cover' if the video aspect ratio is wider than the element aspect ratio\r\n                        //   (scaled height matches element height and scaled width overflows element width)\r\n                        // - for 'contains'/'scale-down' if element aspect ratio is wider than the video aspect ratio\r\n                        //   (scaled height matched element height and element width overflows scaled width)\r\n                        videoScaledHeight = elementHeight;\r\n                        videoScaledWidth = videoScaledHeight * videoAspectRatio;\r\n                    } else {\r\n                        videoScaledWidth = elementWidth;\r\n                        videoScaledHeight = videoScaledWidth / videoAspectRatio;\r\n                    }\r\n                    if (videoObjectFit === 'scale-down') {\r\n                        // for 'scale-down' the dimensions are the minimum of 'contains' and 'none'\r\n                        videoScaledWidth = Math.min(videoScaledWidth, videoWidth);\r\n                        videoScaledHeight = Math.min(videoScaledHeight, videoHeight);\r\n                    }\r\n            }\r\n\r\n            // getComputedStyle is so nice to convert keywords (left, center, right, top, bottom) to percent and makes\r\n            // sure to set the default of 50% if only one or no component was provided, therefore we can be sure that\r\n            // both components are set. Additionally, it converts units other than px (e.g. rem) to px.\r\n            const [videoX, videoY] = videoStyle.objectPosition.split(' ').map((length, i) => {\r\n                const lengthValue = parseFloat(length);\r\n                return length.endsWith('%')\r\n                    ? (!i ? elementWidth - videoScaledWidth : elementHeight - videoScaledHeight) * lengthValue / 100\r\n                    : lengthValue;\r\n            });\r\n\r\n            const regionWidth = this._scanRegion.width || videoWidth;\r\n            const regionHeight = this._scanRegion.height || videoHeight;\r\n            const regionX = this._scanRegion.x || 0;\r\n            const regionY = this._scanRegion.y || 0;\r\n\r\n            const overlayStyle = this.$overlay.style;\r\n            overlayStyle.width = `${regionWidth / videoWidth * videoScaledWidth}px`;\r\n            overlayStyle.height = `${regionHeight / videoHeight * videoScaledHeight}px`;\r\n            overlayStyle.top = `${elementY + videoY + regionY / videoHeight * videoScaledHeight}px`;\r\n            const isVideoMirrored = /scaleX\\(-1\\)/.test(video.style.transform!);\r\n            overlayStyle.left = `${elementX\r\n                + (isVideoMirrored ? elementWidth - videoX - videoScaledWidth : videoX)\r\n                + (isVideoMirrored ? videoWidth - regionX - regionWidth : regionX) / videoWidth * videoScaledWidth}px`;\r\n            // apply same mirror as on video\r\n            overlayStyle.transform = video.style.transform;\r\n        });\r\n    }\r\n\r\n    private static _convertPoints(\r\n        points: QrScanner.Point[],\r\n        scanRegion?: QrScanner.ScanRegion | null,\r\n    ): QrScanner.Point[] {\r\n        if (!scanRegion) return points;\r\n        const offsetX = scanRegion.x || 0;\r\n        const offsetY = scanRegion.y || 0;\r\n        const scaleFactorX = scanRegion.width && scanRegion.downScaledWidth\r\n            ? scanRegion.width / scanRegion.downScaledWidth\r\n            : 1;\r\n        const scaleFactorY = scanRegion.height && scanRegion.downScaledHeight\r\n            ? scanRegion.height / scanRegion.downScaledHeight\r\n            : 1;\r\n        for (const point of points) {\r\n            point.x = point.x * scaleFactorX + offsetX;\r\n            point.y = point.y * scaleFactorY + offsetY;\r\n        }\r\n        return points;\r\n    }\r\n\r\n    private _scanFrame(): void {\r\n        if (!this._active || this.$video.paused || this.$video.ended) return;\r\n        // If requestVideoFrameCallback is available use that to avoid unnecessary scans on the same frame as the\r\n        // camera's framerate can be lower than the screen refresh rate and this._maxScansPerSecond, especially in dark\r\n        // settings where the exposure time is longer. Both, requestVideoFrameCallback and requestAnimationFrame are not\r\n        // being fired if the tab is in the background, which is what we want.\r\n        const requestFrame = 'requestVideoFrameCallback' in this.$video\r\n            // @ts-ignore\r\n            ? this.$video.requestVideoFrameCallback.bind(this.$video)\r\n            : requestAnimationFrame;\r\n        requestFrame(async () => {\r\n            if (this.$video.readyState <= 1) {\r\n                // Skip scans until the video is ready as drawImage() only works correctly on a video with readyState\r\n                // > 1, see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage#Notes.\r\n                // This also avoids false positives for videos paused after a successful scan which remains visible on\r\n                // the canvas until the video is started again and ready.\r\n                this._scanFrame();\r\n                return;\r\n            }\r\n\r\n            const timeSinceLastScan = Date.now() - this._lastScanTimestamp;\r\n            const minimumTimeBetweenScans = 1000 / this._maxScansPerSecond;\r\n            if (timeSinceLastScan < minimumTimeBetweenScans) {\r\n                await new Promise((resolve) => setTimeout(resolve, minimumTimeBetweenScans - timeSinceLastScan));\r\n            }\r\n            // console.log('Scan rate:', Math.round(1000 / (Date.now() - this._lastScanTimestamp)));\r\n            this._lastScanTimestamp = Date.now();\r\n\r\n            let result: QrScanner.ScanResult | undefined;\r\n            try {\r\n                result = await QrScanner.scanImage(this.$video, {\r\n                    scanRegion: this._scanRegion,\r\n                    qrEngine: this._qrEnginePromise,\r\n                    canvas: this.$canvas,\r\n                    fullCanvas: this.$fullCanvas,\r\n                });\r\n            } catch (error) {\r\n                if (!this._active) return;\r\n                this._onDecodeError(error as Error | string);\r\n            }\r\n\r\n            if (QrScanner._disableBarcodeDetector && !(await this._qrEnginePromise instanceof Worker)) {\r\n                // replace the disabled BarcodeDetector\r\n                this._qrEnginePromise = QrScanner.createQrEngine();\r\n            }\r\n\r\n            if (result) {\r\n                if (this._onDecode) {\r\n                    this._onDecode(result);\r\n                } else if (this._legacyOnDecode) {\r\n                    this._legacyOnDecode(result.data);\r\n                }\r\n\r\n                if (this.$codeOutlineHighlight) {\r\n                    clearTimeout(this._codeOutlineHighlightRemovalTimeout);\r\n                    this._codeOutlineHighlightRemovalTimeout = undefined;\r\n                    this.$codeOutlineHighlight.setAttribute(\r\n                        'viewBox',\r\n                        `${this._scanRegion.x || 0} `\r\n                            + `${this._scanRegion.y || 0} `\r\n                            + `${this._scanRegion.width || this.$video.videoWidth} `\r\n                            + `${this._scanRegion.height || this.$video.videoHeight}`,\r\n                    );\r\n                    const polygon = this.$codeOutlineHighlight.firstElementChild!;\r\n                    polygon.setAttribute('points', result.cornerPoints.map(({x, y}) => `${x},${y}`).join(' '));\r\n                    this.$codeOutlineHighlight.style.display = '';\r\n                }\r\n            } else if (this.$codeOutlineHighlight && !this._codeOutlineHighlightRemovalTimeout) {\r\n                // hide after timeout to make it flash less when on some frames the QR code is detected and on some not\r\n                this._codeOutlineHighlightRemovalTimeout = setTimeout(\r\n                    () => this.$codeOutlineHighlight!.style.display = 'none',\r\n                    100,\r\n                );\r\n            }\r\n\r\n            this._scanFrame();\r\n        });\r\n    }\r\n\r\n    private _onDecodeError(error: Error | string): void {\r\n        // default error handler; can be overwritten in the constructor\r\n        if (error === QrScanner.NO_QR_CODE_FOUND) return;\r\n        console.log(error);\r\n    }\r\n\r\n    private async _getCameraStream(): Promise<{ stream: MediaStream, facingMode: QrScanner.FacingMode }> {\r\n        if (!navigator.mediaDevices) throw 'Camera not found.';\r\n\r\n        const preferenceType = /^(environment|user)$/.test(this._preferredCamera)\r\n            ? 'facingMode'\r\n            : 'deviceId';\r\n        const constraintsWithoutCamera: Array<MediaTrackConstraints> = [{\r\n            width: { min: 1024 }\r\n        }, {\r\n            width: { min: 768 }\r\n        }, {}];\r\n        const constraintsWithCamera = constraintsWithoutCamera.map((constraint) => Object.assign({}, constraint, {\r\n            [preferenceType]: { exact: this._preferredCamera },\r\n        }));\r\n\r\n        for (const constraints of [...constraintsWithCamera, ...constraintsWithoutCamera]) {\r\n            try {\r\n                const stream = await navigator.mediaDevices.getUserMedia({ video: constraints, audio: false });\r\n                // Try to determine the facing mode from the stream, otherwise use a guess or 'environment' as\r\n                // default. Note that the guess is not always accurate as Safari returns cameras of different facing\r\n                // mode, even for exact facingMode constraints.\r\n                const facingMode = this._getFacingMode(stream)\r\n                    || (constraints.facingMode\r\n                        ? this._preferredCamera as QrScanner.FacingMode // a facing mode we were able to fulfill\r\n                        : (this._preferredCamera === 'environment'\r\n                            ? 'user' // switch as _preferredCamera was environment but we are not able to fulfill it\r\n                            : 'environment' // switch from unfulfilled user facingMode or default to environment\r\n                        )\r\n                    );\r\n                return { stream, facingMode };\r\n            } catch (e) {}\r\n        }\r\n\r\n        throw 'Camera not found.';\r\n    }\r\n\r\n    private async _restartVideoStream(): Promise<void> {\r\n        // Note that we always pause the stream and not only if !this._paused as even if this._paused === true, the\r\n        // stream might still be running, as it's by default only stopped after a delay of 300ms.\r\n        const wasPaused = this._paused;\r\n        const paused = await this.pause(true);\r\n        if (!paused || wasPaused || !this._active) return;\r\n        await this.start();\r\n    }\r\n\r\n    private static _stopVideoStream(stream : MediaStream): void {\r\n        for (const track of stream.getTracks()) {\r\n            track.stop(); //  note that this will also automatically turn the flashlight off\r\n            stream.removeTrack(track);\r\n        }\r\n    }\r\n\r\n    private _setVideoMirror(facingMode: QrScanner.FacingMode): void {\r\n        // in user facing mode mirror the video to make it easier for the user to position the QR code\r\n        const scaleFactor = facingMode === 'user'? -1 : 1;\r\n        this.$video.style.transform = 'scaleX(' + scaleFactor + ')';\r\n    }\r\n\r\n    private _getFacingMode(videoStream: MediaStream): QrScanner.FacingMode | null {\r\n        const videoTrack = videoStream.getVideoTracks()[0];\r\n        if (!videoTrack) return null; // unknown\r\n        // inspired by https://github.com/JodusNodus/react-qr-reader/blob/master/src/getDeviceId.js#L13\r\n        return /rear|back|environment/i.test(videoTrack.label)\r\n            ? 'environment'\r\n            : /front|user|face/i.test(videoTrack.label)\r\n                ? 'user'\r\n                : null; // unknown\r\n    }\r\n\r\n    private static _drawToCanvas(\r\n        image: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\r\n            | SVGImageElement,\r\n        scanRegion?: QrScanner.ScanRegion | null,\r\n        canvas?: HTMLCanvasElement | null,\r\n        fullCanvas?: HTMLCanvasElement | null,\r\n        disallowCanvasResizing= false,\r\n    ): [HTMLCanvasElement, CanvasRenderingContext2D, HTMLCanvasElement, CanvasRenderingContext2D] {\r\n        canvas = canvas || document.createElement('canvas');\r\n        fullCanvas = fullCanvas || document.createElement('canvas');\r\n        const scanRegionX = scanRegion && scanRegion.x ? scanRegion.x : 0;\r\n        const scanRegionY = scanRegion && scanRegion.y ? scanRegion.y : 0;\r\n        const scanRegionWidth = scanRegion && scanRegion.width\r\n            ? scanRegion.width\r\n            : (image as HTMLVideoElement).videoWidth || image.width as number;\r\n        const scanRegionHeight = scanRegion && scanRegion.height\r\n            ? scanRegion.height\r\n            : (image as HTMLVideoElement).videoHeight || image.height as number;\r\n        const fullWidth = (image as HTMLVideoElement).videoWidth || image.width as number;\r\n        const fullHeight = (image as HTMLVideoElement).videoHeight || image.height as number;\r\n\r\n        if (!disallowCanvasResizing) {\r\n            const canvasWidth = scanRegion && scanRegion.downScaledWidth\r\n                ? scanRegion.downScaledWidth\r\n                : scanRegionWidth;\r\n            const canvasHeight = scanRegion && scanRegion.downScaledHeight\r\n                ? scanRegion.downScaledHeight\r\n                : scanRegionHeight;\r\n            // Setting the canvas width or height clears the canvas, even if the values didn't change, therefore only\r\n            // set them if they actually changed.\r\n            if (canvas.width !== canvasWidth) {\r\n                canvas.width = canvasWidth;\r\n            }\r\n            if (canvas.height !== canvasHeight) {\r\n                canvas.height = canvasHeight;\r\n            }\r\n            if (fullCanvas.width !== fullWidth) {\r\n                fullCanvas.width = fullWidth\r\n            }\r\n            if (fullCanvas.height !== fullHeight) {\r\n                fullCanvas.height = fullHeight;\r\n            }\r\n        }\r\n\r\n        const context = canvas.getContext('2d', { alpha: false })!;\r\n        context.imageSmoothingEnabled = false; // gives less blurry images\r\n        context.drawImage(\r\n            image,\r\n            scanRegionX, scanRegionY, scanRegionWidth, scanRegionHeight,\r\n            0, 0, canvas.width, canvas.height,\r\n        );\r\n        \r\n        const fullContext = fullCanvas.getContext('2d', { alpha: false })!;\r\n        fullContext.imageSmoothingEnabled = false; // gives less blurry images\r\n        fullContext.drawImage(\r\n            image, 0, 0, fullCanvas.width, fullCanvas.height,\r\n        );\r\n\r\n        return [canvas, context, fullCanvas, fullContext];\r\n    }\r\n\r\n    private static async _loadImage(\r\n        imageOrFileOrBlobOrUrl: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\r\n            | SVGImageElement | File | Blob | URL | String,\r\n    ): Promise<HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\r\n        | SVGImageElement > {\r\n        if (imageOrFileOrBlobOrUrl instanceof Image) {\r\n            await QrScanner._awaitImageLoad(imageOrFileOrBlobOrUrl);\r\n            return imageOrFileOrBlobOrUrl;\r\n        } else if (imageOrFileOrBlobOrUrl instanceof HTMLVideoElement\r\n            || imageOrFileOrBlobOrUrl instanceof HTMLCanvasElement\r\n            || imageOrFileOrBlobOrUrl instanceof SVGImageElement\r\n            || 'OffscreenCanvas' in window && imageOrFileOrBlobOrUrl instanceof OffscreenCanvas\r\n            || 'ImageBitmap' in window && imageOrFileOrBlobOrUrl instanceof ImageBitmap) {\r\n            return imageOrFileOrBlobOrUrl;\r\n        } else if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob\r\n            || imageOrFileOrBlobOrUrl instanceof URL || typeof imageOrFileOrBlobOrUrl === 'string') {\r\n            const image = new Image();\r\n            if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob) {\r\n                image.src = URL.createObjectURL(imageOrFileOrBlobOrUrl);\r\n            } else {\r\n                image.src = imageOrFileOrBlobOrUrl.toString();\r\n            }\r\n            try {\r\n                await QrScanner._awaitImageLoad(image);\r\n                return image;\r\n            } finally {\r\n                if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob) {\r\n                    URL.revokeObjectURL(image.src);\r\n                }\r\n            }\r\n        } else {\r\n            throw 'Unsupported image type.';\r\n        }\r\n    }\r\n\r\n    private static async _awaitImageLoad(image: HTMLImageElement): Promise<void> {\r\n        if (image.complete && image.naturalWidth !== 0) return; // already loaded\r\n        await new Promise<void>((resolve, reject) => {\r\n            const listener = (event: ErrorEvent | Event) => {\r\n                image.removeEventListener('load', listener);\r\n                image.removeEventListener('error', listener);\r\n                if (event instanceof ErrorEvent) {\r\n                    reject('Image load error');\r\n                } else {\r\n                    resolve();\r\n                }\r\n            };\r\n            image.addEventListener('load', listener);\r\n            image.addEventListener('error', listener);\r\n        });\r\n    }\r\n\r\n    private static async _postWorkerMessage(\r\n        qrEngineOrQrEnginePromise: Worker | BarcodeDetector | Promise<Worker | BarcodeDetector>,\r\n        type: string,\r\n        data?: any,\r\n        transfer?: Transferable[],\r\n    ): Promise<number> {\r\n        return QrScanner._postWorkerMessageSync(await qrEngineOrQrEnginePromise, type, data, transfer);\r\n    }\r\n\r\n    // sync version of _postWorkerMessage without performance overhead of async functions\r\n    private static _postWorkerMessageSync(\r\n        qrEngine: Worker | BarcodeDetector,\r\n        type: string,\r\n        data?: any,\r\n        transfer?: Transferable[],\r\n    ): number {\r\n        if (!(qrEngine instanceof Worker)) return -1;\r\n        const id = QrScanner._workerMessageId++;\r\n        qrEngine.postMessage({\r\n            id,\r\n            type,\r\n            data,\r\n        }, transfer);\r\n        return id;\r\n    }\r\n}\r\n\r\ndeclare namespace QrScanner {\r\n    export interface ScanRegion {\r\n        x?: number;\r\n        y?: number;\r\n        width?: number;\r\n        height?: number;\r\n        downScaledWidth?: number;\r\n        downScaledHeight?: number;\r\n    }\r\n\r\n    export type FacingMode = 'environment' | 'user';\r\n    export type DeviceId = string;\r\n\r\n    export interface Camera {\r\n        id: DeviceId;\r\n        label: string;\r\n    }\r\n\r\n    export type InversionMode = 'original' | 'invert' | 'both';\r\n\r\n    export interface Point {\r\n        x: number;\r\n        y: number;\r\n    }\r\n\r\n    export interface ScanResult {\r\n        data: string;\r\n        // In clockwise order, starting at top left, but this might not be guaranteed in the future.\r\n        cornerPoints: QrScanner.Point[];\r\n        image: HTMLCanvasElement;\r\n    }\r\n}\r\n\r\n// simplified from https://wicg.github.io/shape-detection-api/#barcode-detection-api\r\ndeclare class BarcodeDetector {\r\n    constructor(options?: { formats: string[] });\r\n    static getSupportedFormats(): Promise<string[]>;\r\n    detect(image: ImageBitmapSource): Promise<Array<{ rawValue: string, cornerPoints: QrScanner.Point[] }>>;\r\n}\r\n\r\n// simplified from https://github.com/lukewarlow/user-agent-data-types/blob/master/index.d.ts\r\ndeclare global {\r\n    interface Navigator {\r\n        readonly userAgentData?: {\r\n            readonly platform: string;\r\n            readonly brands: Array<{\r\n                readonly brand: string;\r\n                readonly version: string;\r\n            }>;\r\n            getHighEntropyValues(hints: string[]): Promise<{\r\n                readonly architecture?: string;\r\n                readonly platformVersion?: string;\r\n            }>;\r\n        };\r\n    }\r\n}\r\n\r\nexport default QrScanner;\r\n"],"names":["QrScanner","workerPath","console","warn","hasCamera","length","listCameras","e","requestLabels","navigator","mediaDevices","enumerateCameras","filter","enumerateDevices","device","kind","openedStream","every","camera","label","getUserMedia","audio","video","map","i","id","deviceId","_stopVideoStream","constructor","onDecode","canvasSizeOrOnDecodeErrorOrOptions","canvasSizeOrCalculateScanRegion","preferredCamera","_legacyCanvasSize","DEFAULT_CANVAS_SIZE","_preferredCamera","_maxScansPerSecond","_lastScanTimestamp","_destroyed","_flashOn","_paused","_active","$video","$canvas","document","createElement","$fullCanvas","_onDecode","_legacyOnDecode","_onDecodeError","options","onDecodeError","_calculateScanRegion","calculateScanRegion","maxScansPerSecond","_onPlay","bind","_onLoadedMetaData","_onVisibilityChange","_updateOverlay","disablePictureInPicture","playsInline","muted","shouldHideVideo","hidden","body","contains","appendChild","parentElement","highlightScanRegion","highlightCodeOutline","gotExternalOverlay","overlay","$overlay","overlayStyle","style","position","display","pointerEvents","classList","add","innerHTML","firstElementChild","animate","transform","duration","iterations","Infinity","direction","easing","videoContainer","insertBefore","nextSibling","insertAdjacentHTML","$codeOutlineHighlight","lastElementChild","_scanRegion","requestAnimationFrame","videoStyle","window","getComputedStyle","setProperty","visibility","opacity","width","height","removeChild","addEventListener","_qrEnginePromise","createQrEngine","hasFlash","stream","srcObject","MediaStream","_getCameraStream","getVideoTracks","getSettings","isFlashOn","toggleFlash","turnFlashOff","turnFlashOn","applyConstraints","advanced","torch","_restartVideoStream","destroy","removeEventListener","stop","_postWorkerMessage","start","Error","location","protocol","play","facingMode","_setVideoMirror","catch","pause","stopStreamImmediately","stopStream","Promise","resolve","setTimeout","setCamera","facingModeOrDeviceId","scanImage","imageOrFileOrBlobOrUrl","scanRegionOrOptions","qrEngine","canvas","fullCanvas","disallowCanvasResizing","alsoTryWithoutScanRegion","scanRegion","returnDetailedScanResult","image","canvasContext","all","_loadImage","_drawToCanvas","detailedScanResult","Worker","qrEngineWorker","gotExternalEngine","_postWorkerMessageSync","reject","timeout","onMessage","onError","expectedResponseId","event","data","clearTimeout","cornerPoints","_convertPoints","NO_QR_CODE_FOUND","error","errorMessage","message","imageData","buffer","race","scanResult","detect","rawValue","test","_disableBarcodeDetector","setGrayscaleWeights","red","green","blue","useIntegerApproximation","setInversionMode","inversionMode","createWorker","import_203","then","module","BarcodeDetector","getSupportedFormats","includes","userAgentData","brands","some","brand","version","parseInt","platform","getHighEntropyValues","architecture","platformVersion","formats","_scanFrame","scanRegionSize","Math","round","min","smallestDimension","videoWidth","videoHeight","x","y","downScaledWidth","downScaledHeight","offsetWidth","offsetHeight","offsetLeft","offsetTop","objectFit","elementWidth","elementHeight","videoObjectFit","videoScaledWidth","videoScaledHeight","videoAspectRatio","elementAspectRatio","videoX","videoY","objectPosition","split","lengthValue","parseFloat","endsWith","regionWidth","regionHeight","regionX","regionY","top","elementY","isVideoMirrored","left","elementX","points","offsetX","offsetY","scaleFactorX","scaleFactorY","point","paused","ended","requestFrame","requestVideoFrameCallback","readyState","timeSinceLastScan","Date","now","minimumTimeBetweenScans","result","_codeOutlineHighlightRemovalTimeout","undefined","setAttribute","join","log","preferenceType","constraintsWithoutCamera","constraint","Object","exact","constraints","constraintsWithCamera","_getFacingMode","wasPaused","track","removeTrack","scaleFactor","videoStream","videoTrack","scanRegionX","scanRegionY","fullWidth","fullHeight","scanRegionWidth","scanRegionHeight","canvasWidth","canvasHeight","context","getContext","alpha","imageSmoothingEnabled","drawImage","fullContext","Image","_awaitImageLoad","HTMLVideoElement","HTMLCanvasElement","SVGImageElement","OffscreenCanvas","ImageBitmap","File","Blob","URL","src","createObjectURL","toString","revokeObjectURL","complete","naturalWidth","listener","ErrorEvent","qrEngineOrQrEnginePromise","type","transfer","postMessage","_workerMessageId"],"mappings":"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"}